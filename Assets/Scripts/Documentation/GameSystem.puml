@startuml GameSystem
allow_mixing
skinparam ComponentBackgroundColor LightSkyBlue
title Hi√©rarchie des scripts et GameObjects

!include toImport.puml

class GameManager{
    - PlayerType playerType
    - gameMode : GameMode
    + gameState : GameState
    - board : Board
    - cardPrefab : GameObject
    - cloudSpawnerPrefab : GameObject
    - humanPlayerPrefab : HumanPlayer
    - aiPlayerPrefab : AIPlayer
    - humanPlayerInstance : HumanPlayer
    - aiPlayerInstance : AIPlayer
    - playerInputNotifiers : List<PlayerInputNotifier>
    - gameStarted : bool


    - Start() : void 
    + StartGame() : void
    - HandlePlayerInput(GameObject clickedObject) : void
    + Update() : void
    - DrawCardToHand(Player player) : void
    - CreateCardInDeck(CardData cardData) : Card
    - PopulatePlayerDeck() : void
    - InitializePlayerStartingResources(Player player, List<Tile> tiles) : void
    - AssignStartingTiles(Player player, List<Tile> tiles, int count) : void
    + RegisterObserversToPlayer(Player player) : void
}
note right of GameManager::Update()
Trigger AI move when 
it's the AI's turn.

OnPlayerInput?.Invoke(move);
end note

class GameState {
    - PLAYER_AMOUNT : int
    - WINNING_POINTS_AMOUNT : int
    + players : List<Player>
    + Player currentInstancePlayer
    + currentPlayerTurn : int
    + turnCount : int
    - currentBoard : Board


    + GetCurrentBoard() : Board
    + HasPlayerWon(player : Player) : bool
    + GetPlayableCards(player : Player) : List<Card>
    + PlayCard(cardAction : Card) : GameState
    + SetCurrentPlayerTurnToNextPlayer() : void
    + GetNextPlayingPlayerIndex() : int
    + getCurrentPlayingPlayer() : Player
    + SetBoard(Board board) : void
}

abstract class Player{
    + points : int
    + observers : List<Observer>
    + currentRessources : Dictionary<RessourceTypes, int>
    + ownedTiles : List<Tile>
    + deck : List<Card>
    + hand : List<Card>
    + discardPile : List<Card>
    + Tile selectedTile

    + {abstract} GetBestPlayableCard() : Card
    + AddCardInDeck(card : Card) : void
    + MoveCardFromDeckToHand(card : Card) : void
    + MoveCardFromHandToDiscardPile(card : Card) : void
    + AddOwnedTile(tile : Tile) : void
    + RemoveOwnedTile(tile : Tile) : void
    + ChangeSelectedTile(Tile tile) : void
    + ComputeRessources() : void
    + RegisterObserver(Observer observer) : void
    + NotifyObservers() : void
}

class HumanPlayer{
    + GetBestPlayableCard() : Card
}

class AIPlayer{
    + GetBestPlayableCard() : Card
    - MiniMax() : int
}
note left of AIPlayer::GetBestPlayableCard
AI behavior logic
end note

class Card {
    + cost : Dictionary<RessourceTypes, int>
    + effectList : List<ICardEffect>
    - TextMeshProUGUI titleText
    - TextMeshProUGUI ressourceText

    + InitializeCard(string titleText, string ressourceText, List<ICardEffect> effectList, Dictionary<RessourceTypes, int> cost) : void
    + Start()
    + AddEffect(ICardEffect effect) : void
    + AddCost(RessourceTypes ressource, int quantity) : void
    + GetCost() : Dictionary<RessourceTypes, int>
    + ApplyEffects(gameState : GameState) : void
    + CanBePlayed(Dictionary<RessourceTypes, int> playerResources) : bool
    + OnClick(GameState gameState) : void
    + SelectedVisual() : void
    + NormalVisual() : void
}

interface ICardEffect{
    +void ApplyEffect()
}

class GainPointEffect{
    + void ApplyEffect()
}

class Board {
    + forestPrefab : GameObject
    + mountainPrefab : GameObject
    + lakePrefab : GameObject
    + plainPrefab : GameObject
    + desertPrefab : GameObject
    + animalPrefabs : GameObject[]
    + OnBoardGenerated : event Action
    - grid : TileType[,]
    + radius : int
    - config : GenerationConfig
    + probabilities : Dictionary<TileType, float>

    + isGenerated : bool
    + Awake() : void
    + CreateBoard() : void
    - PlaceAnimals() : void
    - IsTileGenerated(int q, int r) : bool
    - FixLonelyLakes() : void
    - CountNeighbors(int q, int r) : int
    - IsInsideMap(int q, int r) : bool
    - GetTilePrefab(TileType type) : GameObject
    - AxialToIsometric(int q, int r) : Vector3
    - GetRandomTileType(Dictionary<TileType, float> probabilities) : TileType
    + LogAllTiles() : void
    + GetAllTiles() : List<Tile>
    + InitializePlayerResources(Player player) : void
}

note left of Board::CreateBoard
  Responsible for
  procedural creation
end note

class Tile {
    + producedRessources : Dictionary<RessourceTypeEnum, int>
    + tileType : TileTypeEnum
    + owner : Player

    - AssignResources() : void
    + OnClick() : void
    + Initialize(TileType type) : void
}

class PlayerInputNotifier {
    + OnGameObjectClicked : event Action<GameObject>
    + OnMouseDown() : void
}
note right of PlayerInputNotifier::Update()
// Notify all observers that 
// a move has been made.
OnPlayerInput?.Invoke(move);    
end note

interface IClickable {
    OnClick() : void
}

class GenerationConfig {
    + float forestProbability
    + float mountainProbability
    + float lakeProbability
    + float plainProbability
    + float desertProbability
    + bool preventLargeDeserts
    + float maxDesertClusterRatio
    + bool forceLakeNearMountains
    + bool forceForestNearLakes

    + static LoadFromJson() : GenerationConfig
}

class CameraController {
    - cam : Camera
    + moveSpeed : float
    + panSpeed : float
    + zoomSpeed : float
    + minZoom : float
    + maxZoom : float
    - dragOrigin : Vector3
    - Start() : void
    - Update() : void
    - HandlePan() : void
    - HandleZoom() : void
}

class SceneChanger {
    + {static} Instance : SceneChanger
    - gameScene : string
    - homeScene : string
    - gameManagerPrefab : GameObject
    - gameMode : GameMode
    - Awake() : void
    - OnSceneLoaded(Scene scene, LoadSceneMode mode) : void
    - OnEnable() : void
    - OnDisable() : void
    - {static} SceneChange(string scene) : void
    + GameStartCivilisation() : void
    + GameStartWorld() : void
    + GameStart() : void
    + Home() : void
    + QuitApp() : void
}

class MonoBehavior #LightGreen

component SceneManagerPrefab
component GameManagerPrefab
component humanPlayerPrefab
component aiPlayerPrefab
component TilePrefabs
component AnimalPrefab
component CardPrefab

GameManagerPrefab -d-o "1..1" GameManager : "Has"
GameManager -l-o humanPlayerPrefab : "Has"
GameManager -l-o aiPlayerPrefab : "Has"

HumanPlayer -l--o GameManager : "Has"
AIPlayer -l--o GameManager : "Has"
PlayerInputNotifier --u---o "1" GameManager : "Subscribes to each notifier\not all Tile and Card"

GameManager -d-|> MonoBehavior
GameState -l-o "1..1 " GameManager : " Has"
Board -r-o "  1  " GameManager : " Has"

GameState -d-|> MonoBehavior
Board -r-o "  1  " GameState : " Has"
Player --u---o "2" GameState : "Has"

Player -d-|> MonoBehavior
Observer --o Player : "Has"
Card --o Player : "Has"
Tile -l--o Player : "Has"

HumanPlayer --l--|> Player
AIPlayer -l-|> Player

AnimationController -d-|> MonoBehavior

GainPointEffect .r.> ICardEffect

Card ---r---|> AnimationController
Card <.d. "\t1" IClickable : " Implements"
Card -u-o "0..*" Player : "\t\t\t\nHas"
Card o-d- "1..*" ICardEffect : " Has"

Board -d-|> MonoBehavior
Board --o AnimalPrefab : "Has"
Board --o TilePrefabs : "Has"
Board --o GenerationConfig : "Has"

Tile -u-|> MonoBehavior
Tile <.d. "\t1" IClickable : " Implements"
Tile --o Player : "Has"

CameraController -u-|> MonoBehavior

humanPlayerPrefab o- "\t1" HumanPlayer : " Has"
aiPlayerPrefab o- "\t1" AIPlayer : " Has"

TilePrefab o- "\t1" PlayerInputNotifier : "Has"
TilePrefab -l--o "\t1" Tile : "Has"

CardPrefab o- "\t1" PlayerInputNotifier : "Has"
CardPrefab -r--o "\t1" Card : "Has"

SceneManagerPrefab --o SceneChanger : "Has"
SceneManagerPrefab -l--o GameManagerPrefab : "Has"

legend
    GameManager is the entry point of the game logic.
    Player and Card classes group implements the strategy pattern.
end legend

@enduml
